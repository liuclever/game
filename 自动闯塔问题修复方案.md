# 自动闯塔问题修复方案

## 问题描述

### 问题1：失败后层数没有回退
**现象**：
- 在第40层挑战失败后，`current_floor` 仍然是40层
- 点击"继续挑战"时，会从第40层开始，但由于上次失败，实际应该重新挑战第40层

**原因**：
- 自动闯塔失败时，`state.current_floor` 没有回退
- 代码中只有胜利时才会 `state.current_floor += 1`
- 失败时 `current_floor` 保持不变，但前端显示和逻辑认为已经"结束"

### 问题2：继续挑战调用错误的接口
**现象**：
- 点击"继续挑战"后，直接退出了闯塔
- 实际上是重新开始了自动闯塔，并增加了今日次数

**原因**：
- 前端的"继续挑战"调用的是 `/tower/auto` 接口
- 这个接口会重新开始自动闯塔，并增加今日次数
- 如果今日次数已用完，会直接返回错误

### 问题3：退出闯塔的逻辑不清晰
**现象**：
- 失败后默认就"闯塔结束"了
- 但实际上需要点击"退出闯塔"才是真正结束

**原因**：
- 前端显示逻辑混乱
- 失败后应该明确提示"挑战失败，是否继续挑战？"

## 修复方案

### 方案1：修复自动闯塔的层数逻辑

**问题分析**：
当前逻辑：
```python
if battle.is_victory:
    cleared_floor = state.current_floor
    state.current_floor += 1  # 胜利时前进到下一层
    if cleared_floor > state.max_floor_record:
        state.max_floor_record = cleared_floor
else:
    stopped_reason = "all_dead"
    break  # 失败时停止，但 current_floor 没有变化
```

**修复方案A：失败时不改变 current_floor**（推荐）

保持当前逻辑，但明确语义：
- `current_floor` 表示"下一次要挑战的层数"
- 失败时保持不变，表示下次继续挑战这一层
- 胜利时 +1，表示下次挑战下一层

**修复方案B：失败时回退 current_floor**

```python
if battle.is_victory:
    cleared_floor = state.current_floor
    state.current_floor += 1
    if cleared_floor > state.max_floor_record:
        state.max_floor_record = cleared_floor
else:
    # 失败时不改变 current_floor，保持在当前层
    # 或者明确记录失败的层数
    stopped_reason = "all_dead"
    break
```

**推荐方案A**，因为当前逻辑已经是正确的，只需要修复前端的理解和显示。

### 方案2：修复继续挑战的逻辑

**当前问题**：
```javascript
// 继续挑战（再打一次当前层）
const continueChallenge = async () => {
  // ...
  const res = await http.post('/tower/auto', {  // ❌ 错误：调用自动闯塔接口
    tower_type: towerType.value,
    use_buff: buffEnabled.value,
  })
  // ...
}
```

**修复方案A：继续挑战不增加今日次数**（推荐）

修改后端 `auto_challenge` 方法，添加一个参数 `is_continue`：

```python
def auto_challenge(
    self,
    user_id: int,
    tower_type: str,
    player_beasts: List[PlayerBeast],
    use_buff: bool = True,
    is_continue: bool = False,  # 新增：是否是继续挑战
) -> AutoChallengeResult:
    """自动闯塔 - 一次性计算所有层"""
    state = self.state_repo.get_by_user_id(user_id, tower_type)
    state.reset_daily_if_needed()

    # 今日次数限制
    self._ensure_can_challenge_today(user_id=user_id, state=state)

    config = self.config_repo.get_tower_config(tower_type)
    max_floor = config.get("max_floor", 120)

    # 只有首次自动闯塔时才增加今日次数
    if not is_continue:
        state.today_count += 1
    
    # ... 其余逻辑不变
```

前端修改：
```javascript
// 继续挑战（再打一次当前层）
const continueChallenge = async () => {
  loading.value = true
  error.value = ''
  
  try {
    const res = await http.post('/tower/auto', {
      tower_type: towerType.value,
      use_buff: buffEnabled.value,
      is_continue: true,  // 新增：标记为继续挑战
    })
    
    // ... 其余逻辑不变
  }
}
```

**修复方案B：创建单独的继续挑战接口**

创建新接口 `/tower/continue`：
```python
@tower_bp.post("/tower/continue")
def tower_continue_challenge():
    """继续挑战当前层（不增加今日次数）"""
    user_id = get_current_user_id()
    if not user_id:
        return jsonify({"ok": False, "error": "请先登录"})
    
    data = request.get_json() or {}
    tower_type = data.get("tower_type", "tongtian")
    use_buff = data.get("use_buff", True)
    
    # 调用 auto_challenge，但标记为继续挑战
    result = services.tower_service.auto_challenge(
        user_id=user_id,
        tower_type=tower_type,
        player_beasts=player_beasts,
        use_buff=use_buff,
        is_continue=True,
    )
    
    # ... 返回结果
```

**推荐方案A**，因为更简单，只需要添加一个参数。

### 方案3：优化前端显示逻辑

**当前问题**：
- 失败后显示"闯塔结束"，但实际上可以继续挑战
- "继续挑战"和"退出闯塔"的区别不明确

**修复方案**：

1. **明确状态显示**：
```vue
<!-- 失败后的提示 -->
<div v-if="!lastBattle.is_victory" class="section red">
  第{{ currentFloor }}层挑战失败！
</div>

<div class="section">
  <a class="link" @click="continueChallenge">重新挑战第{{ currentFloor }}层</a>
  <span class="gray">（不消耗今日次数）</span>
</div>

<div class="section">
  <a class="link" @click="exitChallenge">退出闯塔</a>
  <span class="gray">（发放累积奖励）</span>
</div>
```

2. **添加确认对话框**：
```javascript
const exitChallenge = async () => {
  if (!confirm('确定要退出闯塔吗？累积的奖励将发放到背包。')) {
    return
  }
  
  // ... 退出逻辑
}
```

3. **优化状态文案**：
```javascript
const statusText = computed(() => {
  if (loading.value) return '战斗中...'
  if (!lastBattle.value) return '准备中'
  if (lastBattle.value.is_victory) {
    if (currentFloor.value > maxFloor.value) {
      return '已通关所有层！'
    }
    return `第${currentFloor.value - 1}层通关，准备挑战第${currentFloor.value}层`
  }
  return `第${currentFloor.value}层挑战失败`
})
```

## 实现步骤

### 步骤1：修改后端 auto_challenge 方法

**文件**：`application/services/tower_service.py`

```python
def auto_challenge(
    self,
    user_id: int,
    tower_type: str,
    player_beasts: List[PlayerBeast],
    use_buff: bool = True,
    is_continue: bool = False,  # 新增参数
) -> AutoChallengeResult:
    """自动闯塔 - 一次性计算所有层
    
    Args:
        is_continue: 是否是继续挑战（不增加今日次数）
    """
    state = self.state_repo.get_by_user_id(user_id, tower_type)
    state.reset_daily_if_needed()

    # 今日次数限制
    self._ensure_can_challenge_today(user_id=user_id, state=state)

    config = self.config_repo.get_tower_config(tower_type)
    max_floor = config.get("max_floor", 120)

    # 只有首次自动闯塔时才增加今日次数
    if not is_continue:
        state.today_count += 1
    
    # ... 其余逻辑不变
```

### 步骤2：修改后端 API 接口

**文件**：`interfaces/routes/tower_routes.py`

```python
@tower_bp.post("/tower/auto")
def tower_auto_challenge():
    """自动闯塔"""
    user_id = get_current_user_id()
    if not user_id:
        return jsonify({"ok": False, "error": "请先登录"})
    
    data = request.get_json() or {}
    tower_type = data.get("tower_type", "tongtian")
    use_buff = data.get("use_buff", True)
    is_continue = data.get("is_continue", False)  # 新增参数
    
    # ... 获取幻兽列表
    
    try:
        result = services.tower_service.auto_challenge(
            user_id=user_id,
            tower_type=tower_type,
            player_beasts=player_beasts,
            use_buff=use_buff,
            is_continue=is_continue,  # 传递参数
        )
        
        # ... 返回结果
    except Exception as e:
        # ... 错误处理
```

### 步骤3：修改前端继续挑战逻辑

**文件**：`interfaces/client/src/features/tower/TowerChallengePage.vue`

```javascript
// 继续挑战（再打一次当前层）
const continueChallenge = async () => {
  loading.value = true
  error.value = ''
  
  try {
    const res = await http.post('/tower/auto', {
      tower_type: towerType.value,
      use_buff: buffEnabled.value,
      is_continue: true,  // 新增：标记为继续挑战
    })
    
    if (res.data.ok) {
      const result = res.data.result
      const state = res.data.state
      
      applyAutoResult(result, state)
      
      // 更新缓存
      const cacheKey = `autoTowerResult:${towerType.value}`
      sessionStorage.setItem(cacheKey, JSON.stringify({ result, state }))
    } else {
      error.value = res.data.error || '挑战失败'
    }
  } catch (e) {
    console.error('继续挑战失败', e)
    error.value = e?.response?.data?.error || e?.message || '网络错误'
  } finally {
    loading.value = false
  }
}
```

### 步骤4：优化前端显示

**文件**：`interfaces/client/src/features/tower/TowerChallengePage.vue`

```vue
<template>
  <!-- ... -->
  
  <!-- 当前状态 -->
  <div class="section">
    状态: <span :class="statusClass">{{ statusText }}</span>
  </div>
  
  <!-- 失败后的操作 -->
  <div v-if="lastBattle && !lastBattle.is_victory" class="section">
    <a class="link" @click="continueChallenge">
      重新挑战第{{ currentFloor }}层
    </a>
    <span class="gray">（不消耗今日次数）</span>
  </div>
  
  <!-- 退出闯塔 -->
  <div class="section">
    <a class="link" @click="exitChallenge">退出闯塔</a>
    <span class="gray">（发放累积奖励到背包）</span>
  </div>
  
  <!-- ... -->
</template>

<script setup>
// ... 现有代码

// 状态文本
const statusText = computed(() => {
  if (loading.value) return '战斗中...'
  if (!lastBattle.value) return '准备中'
  
  const floor = currentFloor.value
  if (lastBattle.value.is_victory) {
    if (floor > maxFloor.value) {
      return '已通关所有层！'
    }
    return `第${floor - 1}层通关`
  }
  return `第${floor}层挑战失败`
})

// 状态样式
const statusClass = computed(() => {
  if (loading.value) return 'gray'
  if (!lastBattle.value) return 'gray'
  if (lastBattle.value.is_victory) return 'green'
  return 'red'
})

// 退出闯塔（添加确认）
const exitChallenge = async () => {
  if (!confirm('确定要退出闯塔吗？累积的奖励将发放到背包。')) {
    return
  }
  
  // ... 现有退出逻辑
}
</script>
```

## 测试验证

### 测试用例1：失败后继续挑战
1. 开始自动闯塔
2. 在某一层（如第40层）挑战失败
3. 点击"重新挑战第40层"
4. 验证：
   - ✅ 重新挑战第40层（不是第41层）
   - ✅ 不增加今日次数
   - ✅ 可以多次重试

### 测试用例2：失败后退出
1. 开始自动闯塔
2. 在某一层挑战失败
3. 点击"退出闯塔"
4. 验证：
   - ✅ 累积奖励发放到背包
   - ✅ 返回闯塔主页
   - ✅ 下次进入时从失败的层开始

### 测试用例3：今日次数限制
1. 使用完今日次数
2. 在某一层挑战失败
3. 点击"重新挑战"
4. 验证：
   - ✅ 可以继续挑战（不消耗次数）
   - ✅ 不提示"今日次数已用完"

## 注意事项

1. **今日次数计算**：
   - 首次自动闯塔：消耗1次
   - 继续挑战：不消耗次数
   - 退出后重新开始：消耗1次

2. **层数状态**：
   - `current_floor` 表示"下一次要挑战的层数"
   - 失败时保持不变
   - 胜利时 +1

3. **奖励发放**：
   - 只有点击"退出闯塔"才发放累积奖励
   - 继续挑战不发放奖励

4. **缓存处理**：
   - 继续挑战后更新缓存
   - 退出闯塔后清除缓存

## 总结

**问题根源**：
1. 前端"继续挑战"调用了错误的接口（应该标记为继续挑战）
2. 后端每次调用都增加今日次数（应该区分首次和继续）
3. 前端显示逻辑不清晰（应该明确状态和操作）

**解决方案**：
1. ✅ 添加 `is_continue` 参数，区分首次和继续挑战
2. ✅ 继续挑战不增加今日次数
3. ✅ 优化前端显示，明确状态和操作
4. ✅ 添加确认对话框，避免误操作
