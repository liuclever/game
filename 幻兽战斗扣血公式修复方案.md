# 幻兽战斗扣血公式修复方案

## 需求说明

所有涉及幻兽对战的扣血公式需要统一修改为以下规则：

### 新的扣血公式

#### 第一种情况（己方攻击 - 对方防御 ≥ 0）
- **物理伤害**：对方扣血数值 = (己方物攻数值 - 对方物防数值) × 0.069（四舍五入）
- **法术伤害**：对方扣血数值 = (己方法攻数值 - 对方法防数值) × 0.069（四舍五入）

#### 第二种情况（攻击 - 防御 < 0）
- **固定扣血**：对方固定扣血 5 点

### 涉及的战斗场景

1. **竞技场**的幻兽战斗
2. **地图副本**的挑战
3. **盟战**的战斗
4. **闯塔**的战斗
5. **好友间切磋**战斗
6. **战场**的战斗
7. **擂台**的战斗
8. **召唤之王挑战赛**中的幻兽战斗

## 需要修改的文件

### 1. domain/services/pvp_battle_engine.py（核心战斗引擎）✅

**文件位置**：`domain/services/pvp_battle_engine.py`

**需要修改的函数**：`calc_damage()`（第218-268行）

**当前问题**：
- 使用了复杂的随机浮动系数（0.069~0.071）
- 使用了防御档位倍数
- 负数情况使用了区间伤害（250~300 或 20~40）

**修改方案**：
```python
def calc_damage(attacker: PvpBeast, defender: PvpBeast, attacker_player_level: int) -> int:
    """按照新需求计算一次攻击的扣血量。

    - 第一种情况（攻 - 防 >= 0）：
        damage = (攻 - 防) × 0.069，四舍五入
    - 第二种情况（攻 - 防 < 0）：
        固定扣血 5 点
    """
    diff, defense_value, _ = _pick_attack_and_defense(attacker, defender)

    if diff >= 0:
        # 攻 - 防 >= 0：使用固定系数 0.069
        raw = diff * 0.069
        dmg = round(raw)  # 四舍五入
    else:
        # 攻 - 防 < 0：固定扣血 5 点
        dmg = 5

    return max(1, dmg)  # 最小伤害为 1
```

**影响范围**：
- 所有使用 `run_pvp_battle()` 的战斗场景
- 包括：擂台、镇妖、战场、盟战、好友切磋等

### 2. domain/services/battle_engine.py（旧版战斗引擎）

**文件位置**：`domain/services/battle_engine.py`

**需要修改的类**：`SimpleDamageCalculator` 和 `RandomDamageCalculator`

**当前问题**：
- 简单的攻击 - 防御计算
- 没有使用 0.069 系数
- 没有处理负数情况

**修改方案**：
```python
class SimpleDamageCalculator(DamageCalculator):
    """简单伤害计算：使用新的扣血公式"""
    
    def calculate(self, attacker: BeastStats, defender: BeastStats) -> int:
        if attacker.is_magic_type():
            diff = attacker.magic_attack - defender.magic_defense
        else:
            diff = attacker.physical_attack - defender.physical_defense
        
        if diff >= 0:
            damage = round(diff * 0.069)
        else:
            damage = 5
        
        return max(1, damage)


class RandomDamageCalculator(DamageCalculator):
    """带随机浮动的伤害计算（已废弃，建议统一使用 SimpleDamageCalculator）"""
    
    def __init__(self, variance: float = 0.0):
        # 新规则不再使用随机浮动，保留接口兼容性
        self.variance = 0.0
    
    def calculate(self, attacker: BeastStats, defender: BeastStats) -> int:
        # 统一使用新公式
        if attacker.is_magic_type():
            diff = attacker.magic_attack - defender.magic_defense
        else:
            diff = attacker.physical_attack - defender.physical_defense
        
        if diff >= 0:
            damage = round(diff * 0.069)
        else:
            damage = 5
        
        return max(1, damage)
```

**影响范围**：
- 使用 `BattleEngine` 的旧代码（如果还有的话）

### 3. application/services/tower_service.py（闯塔服务）

**文件位置**：`application/services/tower_service.py`

**需要修改的方法**：
- `calc_damage()` - 第301-304行（旧方法，已废弃）
- `calc_damage_with_type()` - 第306-323行（旧方法，已废弃）

**当前问题**：
- 这两个方法已经不再使用（闯塔已改用统一 PVP 引擎）
- 但为了代码一致性，建议更新或标记为废弃

**修改方案**：
```python
def calc_damage(self, attacker_attack: int, defender_defense: int) -> int:
    """计算伤害（已废弃，闯塔现使用统一 PVP 引擎）"""
    diff = attacker_attack - defender_defense
    if diff >= 0:
        damage = round(diff * 0.069)
    else:
        damage = 5
    return max(1, damage)

def calc_damage_with_type(
    self,
    attacker,  # PlayerBeast 或 TowerGuardian
    defender,  # PlayerBeast 或 TowerGuardian
) -> int:
    """根据特性计算伤害（已废弃，闯塔现使用统一 PVP 引擎）"""
    # 判断攻击方是法系还是物系
    if attacker.is_magic_type():
        diff = attacker.magic_attack - defender.magic_defense
    else:
        diff = attacker.physical_attack - defender.physical_defense
    
    if diff >= 0:
        damage = round(diff * 0.069)
    else:
        damage = 5
    
    return max(1, damage)
```

**影响范围**：
- 闯塔战斗已使用 `run_pvp_battle()`，这些方法仅作兼容保留

### 4. application/services/zhenyao_service.py（镇妖服务）

**文件位置**：`application/services/zhenyao_service.py`

**需要修改的方法**：`_calc_damage()` - 第809-823行

**当前问题**：
- 使用了 `攻击力 - 防御力/2` 的公式
- 有 ±20% 的随机浮动

**修改方案**：
```python
def _calc_damage(self, attacker, defender) -> int:
    """计算伤害（已废弃，镇妖现使用统一 PVP 引擎）"""
    # 判断攻击方是法系还是物系
    if attacker.nature and "法系" in attacker.nature:
        diff = attacker.magic_attack - defender.magic_defense
    else:
        diff = attacker.physical_attack - defender.physical_defense
    
    if diff >= 0:
        damage = round(diff * 0.069)
    else:
        damage = 5
    
    return max(1, damage)
```

**影响范围**：
- 镇妖战斗已使用 `run_pvp_battle()`，这个方法仅作兼容保留

## 修改优先级

### 高优先级（必须修改）✅
1. **domain/services/pvp_battle_engine.py** - 核心战斗引擎，影响所有 PVP 战斗

### 中优先级（建议修改）
2. **domain/services/battle_engine.py** - 旧版引擎，可能还有部分代码在使用

### 低优先级（可选修改）
3. **application/services/tower_service.py** - 已废弃的方法，仅作兼容
4. **application/services/zhenyao_service.py** - 已废弃的方法，仅作兼容

## 测试验证

修改完成后，需要运行以下测试文件验证：

1. `test_new_damage_formula.py` - 新伤害公式测试
2. `test_arena_*.py` - 擂台相关测试
3. `test_alliance_war_*.py` - 盟战相关测试
4. `test_occupy_arena.py` - 擂台占领测试

## 注意事项

1. **四舍五入**：使用 Python 的 `round()` 函数
2. **最小伤害**：保持最小伤害为 1 点（避免 0 伤害导致战斗无法结束）
3. **负数情况**：固定扣血 5 点，不再使用复杂的区间伤害
4. **技能系统**：伤害倍数（如必杀 2 倍）在基础伤害之后应用
5. **向后兼容**：旧的战斗记录不受影响，只影响新的战斗

## 实施步骤

1. ✅ 修改 `domain/services/pvp_battle_engine.py` 的 `calc_damage()` 函数
2. 修改 `domain/services/battle_engine.py` 的伤害计算器
3. 更新 `application/services/tower_service.py` 的废弃方法
4. 更新 `application/services/zhenyao_service.py` 的废弃方法
5. 运行测试验证
6. 更新相关文档

## 完成标记

- [x] 创建修复方案文档
- [x] 修改核心战斗引擎（domain/services/pvp_battle_engine.py）
- [x] 修改旧版战斗引擎（domain/services/battle_engine.py）
- [x] 更新废弃方法（tower_service.py 和 zhenyao_service.py）
- [x] 运行测试验证（所有测试通过 ✅）
- [x] 创建完成报告文档

## 修复完成 ✅

所有幻兽战斗扣血公式已成功修改并通过测试验证。详细信息请查看：
- 完成报告：`幻兽战斗扣血公式修复完成报告.md`
- 测试文件：`test_new_damage_formula.py`
