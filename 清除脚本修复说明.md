# 清除脚本语法错误修复说明

## 问题描述

原清除脚本使用了 `TRUNCATE TABLE IF EXISTS` 语法，但 MySQL 不支持这个语法（MySQL 8.0.22 之前的版本）。

### 错误信息
```
[42000][1064] You have an error in your SQL syntax; 
check the manual that corresponds to your MySQL server version 
for the right syntax to use near 'IF EXISTS player_immortalize_pool' at line 1
```

## 解决方案

使用**存储过程**来安全地清除表，自动检查表是否存在。

### 新的实现方式

```sql
-- 创建临时存储过程
CREATE PROCEDURE safe_truncate_table(IN table_name VARCHAR(64))
BEGIN
    DECLARE table_exists INT DEFAULT 0;
    
    -- 检查表是否存在
    SELECT COUNT(*) INTO table_exists
    FROM information_schema.tables 
    WHERE table_schema = 'game_tower' 
    AND table_name = table_name;
    
    -- 如果表存在，则清空
    IF table_exists > 0 THEN
        SET @sql = CONCAT('DELETE FROM `', table_name, '` WHERE 1=1');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 重置自增ID
        SET @sql = CONCAT('ALTER TABLE `', table_name, '` AUTO_INCREMENT = 1');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END IF;
END;

-- 使用存储过程清除表
CALL safe_truncate_table('player');
CALL safe_truncate_table('alliances');
-- ... 其他表
```

## 优势

### 1. 兼容性更好
- ✅ 兼容 MySQL 5.7 及以上版本
- ✅ 不依赖特定版本的语法特性

### 2. 更安全
- ✅ 自动检查表是否存在
- ✅ 只清除存在的表
- ✅ 不会因为表不存在而报错

### 3. 功能完整
- ✅ 清除所有数据（使用 DELETE）
- ✅ 重置自增ID（使用 ALTER TABLE）
- ✅ 效果等同于 TRUNCATE

### 4. 可维护性
- ✅ 代码清晰易懂
- ✅ 易于调试和修改
- ✅ 执行完成后自动清理存储过程

## 性能对比

| 方法 | 速度 | 兼容性 | 安全性 |
|------|------|--------|--------|
| TRUNCATE TABLE | 最快 | 有限制 | 中等 |
| DELETE + ALTER TABLE | 较快 | 最好 | 最好 |
| 存储过程方式 | 较快 | 最好 | 最好 |

## 使用方法

### 执行清除脚本
```bash
mysql -h 8.146.206.229 -u root -p game_tower < sql/999_clear_all_player_and_alliance_data.sql
```

### 预期输出
```
所有玩家和联盟数据已清理完成！
系统配置表（blacklist, lands, level_config, cultivation_config）已保留
```

## 验证

### 检查表是否清空
```sql
SELECT COUNT(*) FROM player;        -- 应该返回 0
SELECT COUNT(*) FROM alliances;     -- 应该返回 0
SELECT COUNT(*) FROM player_beast;  -- 应该返回 0
```

### 检查系统配置表
```sql
SELECT COUNT(*) FROM blacklist;           -- 应该有数据
SELECT COUNT(*) FROM lands;               -- 应该有数据
SELECT COUNT(*) FROM level_config;        -- 应该有数据
SELECT COUNT(*) FROM cultivation_config;  -- 应该有数据
```

## 注意事项

1. **执行前必须备份数据库**
2. **清除操作不可恢复**
3. **建议先在测试环境执行**
4. **执行时间约 10-30 秒**（取决于数据量）

## 技术细节

### 为什么不用 TRUNCATE TABLE？

MySQL 的 `TRUNCATE TABLE` 语法不支持 `IF EXISTS`：

```sql
-- ❌ 错误：MySQL 不支持
TRUNCATE TABLE IF EXISTS player;

-- ✅ 正确：但需要确保表存在
TRUNCATE TABLE player;
```

### 为什么用 DELETE 而不是 TRUNCATE？

1. **灵活性**：DELETE 可以在存储过程中动态执行
2. **兼容性**：DELETE 在所有 MySQL 版本中都支持
3. **安全性**：可以先检查表是否存在
4. **效果相同**：配合 ALTER TABLE 重置自增ID，效果等同于 TRUNCATE

### DELETE vs TRUNCATE 性能差异

对于大表（百万级数据）：
- TRUNCATE：几乎瞬间完成
- DELETE：可能需要几秒到几十秒

对于小表（万级以下数据）：
- 两者性能差异可以忽略不计

本项目的测试数据量通常不大，使用 DELETE 是合适的选择。

## 更新记录

### 2026-01-28（修复版本）
- ✅ 修复 `TRUNCATE TABLE IF EXISTS` 语法错误
- ✅ 改用存储过程实现安全清除
- ✅ 添加自动表存在性检查
- ✅ 添加自增ID重置功能
- ✅ 提高兼容性和安全性

---

**修复完成时间**：2026-01-28  
**测试状态**：✅ 待测试  
**兼容版本**：MySQL 5.7+
