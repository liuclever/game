# 召唤之王正赛自己打自己问题修复说明

## 问题描述

用户反馈：召唤之王挑战赛正赛中，出现自己和自己打的情况。

## 问题原因

### 1. 重复记录

如果同一个玩家在同一阶段（如32强赛）有多条记录，配对时就可能配到自己。

**可能的原因：**
- 晋级逻辑重复执行
- 手动修改数据库导致重复
- 并发问题导致重复插入

### 2. 配对逻辑缺少检查

原代码的配对逻辑：

```python
player_ids = [p['user_id'] for p in players]
random.shuffle(player_ids)

for i in range(0, len(player_ids), 2):
    if i + 1 < len(player_ids):
        player1_id = player_ids[i]
        player2_id = player_ids[i + 1]
        # 直接配对，没有检查是否是同一个人
```

**问题：**
- 如果 `player_ids` 中有重复的ID，就可能出现 `player1_id == player2_id`
- 没有去重逻辑
- 没有检查是否配到自己

## 修复方案

### 方案1：去重（主要修复）

在配对前，对 `player_ids` 进行去重：

```python
player_ids = [p['user_id'] for p in players]
print(f"[召唤之王] {stage}强赛共{len(player_ids)}名选手")

# 去重，防止同一个玩家有多条记录
player_ids = list(dict.fromkeys(player_ids))  # 保持顺序的去重
if len(player_ids) != len(players):
    print(f"[召唤之王] 警告：发现重复记录，去重后剩余{len(player_ids)}名选手")
```

**优点：**
- 从根源上解决问题
- 保持原有顺序（使用 `dict.fromkeys` 而不是 `set`）
- 有日志提示，方便发现数据异常

### 方案2：配对检查（双重保险）

在配对时，检查是否配到自己：

```python
for i in range(0, len(player_ids), 2):
    if i + 1 < len(player_ids):
        player1_id = player_ids[i]
        player2_id = player_ids[i + 1]
        
        # 防止自己和自己打（双重保险）
        if player1_id == player2_id:
            print(f"[召唤之王] 警告：检测到自己和自己配对，跳过")
            continue
```

**优点：**
- 即使去重失败，也能防止自己打自己
- 双重保险，更加安全

## 修复后的完整逻辑

```python
def run_final_stage(stage):
    """执行正赛某一轮次"""
    # ... 前面的代码 ...
    
    # 获取本轮参赛选手
    players = execute_query(
        """SELECT user_id FROM king_final_stage 
           WHERE season = %s AND stage = %s AND is_winner IS NULL
           ORDER BY id ASC""",
        (season, stage)
    )
    
    player_ids = [p['user_id'] for p in players]
    print(f"[召唤之王] {stage}强赛共{len(player_ids)}名选手")
    
    # 去重，防止同一个玩家有多条记录
    player_ids = list(dict.fromkeys(player_ids))
    if len(player_ids) != len(players):
        print(f"[召唤之王] 警告：发现重复记录，去重后剩余{len(player_ids)}名选手")
    
    # 随机打乱顺序
    random.shuffle(player_ids)
    
    # 配对并执行战斗
    match_id = 1
    winners = []
    
    for i in range(0, len(player_ids), 2):
        if i + 1 < len(player_ids):
            player1_id = player_ids[i]
            player2_id = player_ids[i + 1]
            
            # 防止自己和自己打（双重保险）
            if player1_id == player2_id:
                print(f"[召唤之王] 警告：检测到自己和自己配对，跳过")
                continue
            
            # 正常配对和战斗
            # ...
```

## 测试验证

### 诊断脚本

运行诊断脚本检查是否有重复记录：

```bash
python diagnose_king_final_self_match.py
```

**检查内容：**
1. 查询当前赛季的所有正赛记录
2. 检查是否有重复的 `user_id`
3. 检查是否有自己和自己打的情况
4. 显示所有对战列表

### 手动测试

1. 创建测试数据（模拟重复记录）：

```sql
-- 插入重复记录
INSERT INTO king_final_stage (season, user_id, stage, created_at)
VALUES ('2026W04', 1001, '32', NOW());

INSERT INTO king_final_stage (season, user_id, stage, created_at)
VALUES ('2026W04', 1001, '32', NOW());
```

2. 运行正赛：

```python
from domain.services.king_final_service import run_final_stage
run_final_stage('32')
```

3. 检查日志：

```
[召唤之王] 32强赛共2名选手
[召唤之王] 警告：发现重复记录，去重后剩余1名选手
[召唤之王] 1001 轮空，直接晋级
```

## 预防措施

### 1. 防止重复插入

在晋级逻辑中添加检查：

```python
# 检查是否已经存在
existing = execute_query(
    """SELECT id FROM king_final_stage 
       WHERE season = %s AND user_id = %s AND stage = %s""",
    (season, winner_id, next_stage)
)

if not existing:
    # 只有不存在时才插入
    execute_update(
        """INSERT INTO king_final_stage 
           (season, user_id, stage, created_at) 
           VALUES (%s, %s, %s, NOW())""",
        (season, winner_id, next_stage)
    )
```

### 2. 添加唯一索引

在数据库中添加唯一索引，防止重复记录：

```sql
ALTER TABLE king_final_stage 
ADD UNIQUE INDEX idx_season_user_stage (season, user_id, stage);
```

**注意：** 添加唯一索引前，需要先清理已有的重复数据。

### 3. 定期检查

定期运行诊断脚本，检查是否有异常数据：

```bash
# 每周运行一次
python diagnose_king_final_self_match.py
```

## 相关文件

### 修改的文件
- `domain/services/king_final_service.py` - 正赛执行逻辑

### 诊断工具
- `diagnose_king_final_self_match.py` - 诊断脚本

### 数据库表
- `king_final_stage` - 正赛阶段表

## 注意事项

1. **去重保持顺序**：使用 `dict.fromkeys()` 而不是 `set()`，保持原有顺序
2. **双重保险**：既去重又检查，确保万无一失
3. **日志记录**：发现异常时输出警告日志，方便排查问题
4. **数据清理**：如果发现重复记录，需要手动清理数据库

## 总结

召唤之王正赛自己打自己问题已修复：

1. ✓ 添加去重逻辑，防止重复记录导致的问题
2. ✓ 添加配对检查，双重保险防止自己打自己
3. ✓ 添加日志记录，方便发现和排查问题
4. ✓ 提供诊断工具，快速检查数据异常

修复后，即使数据库中有重复记录，也不会出现自己和自己打的情况。
