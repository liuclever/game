# 自动闯塔逻辑修复说明

## 修复日期
2026年1月18日

## 问题描述

用户报告的问题：
1. **挑战失败后状态不明确**：在40层挑战失败后，默认就闯塔结束了，但实际上需要点击"退出闯塔"才是真正结束
2. **继续挑战功能异常**：点击"继续挑战"并没有继续再一次挑战第40层的守塔幻兽，而是直接退出了闯塔

## 问题分析

### 问题1：挑战失败后的状态
**原代码逻辑**：
```javascript
if (stoppedReason.value === 'all_dead') {
  autoEnabled.value = false  // ❌ 错误：关闭了自动闯塔
  battleResult.value = '挑战失败'
}
```

**问题**：
- 挑战失败后，`autoEnabled` 被设置为 `false`
- 这给用户一种"闯塔已结束"的错觉
- 但实际上玩家还在闯塔中，只是需要点击"退出闯塔"才真正结束

### 问题2：继续挑战的逻辑
**原代码逻辑**：
```javascript
const continueChallenge = async () => {
  const res = await http.post('/tower/auto', {
    tower_type: towerType.value,
    use_buff: buffEnabled.value,
  })
  // 直接覆盖了之前的结果
  applyAutoResult(result, state)
}
```

**问题**：
- 每次调用 `auto_challenge` 都会消耗1次闯塔次数
- 继续挑战应该是在同一次闯塔中，不应该再消耗次数
- 新的战斗结果直接覆盖了之前的结果，导致之前的战斗记录丢失

### 问题3：次数消耗逻辑
**原代码逻辑**：
```python
def auto_challenge(...):
    # 每次调用都会 +1
    state.today_count += 1
```

**问题**：
- 首次进入自动闯塔页面：消耗1次 ✅
- 点击"继续挑战"：又消耗1次 ❌ 错误
- 应该只在首次进入时消耗次数

## 修复内容

### 1. 修复挑战失败后的状态显示

#### interfaces/client/src/features/tower/TowerChallengePage.vue

**修改前**：
```javascript
if (stoppedReason.value === 'all_dead') {
  autoEnabled.value = false  // ❌ 关闭自动闯塔
  battleResult.value = '挑战失败'
}
```

**修改后**：
```javascript
if (stoppedReason.value === 'all_dead') {
  // 挑战失败，但不关闭自动闯塔，允许继续挑战
  battleResult.value = '挑战失败'
}
```

**说明**：
- 挑战失败后不再关闭 `autoEnabled`
- 保持"自动闯塔：已经开启"的状态
- 用户可以选择"继续挑战"或"退出此次闯塔"

### 2. 修复继续挑战的逻辑

#### interfaces/client/src/features/tower/TowerChallengePage.vue

**修改前**：
```javascript
const continueChallenge = async () => {
  const res = await http.post('/tower/auto', {
    tower_type: towerType.value,
    use_buff: buffEnabled.value,
  })
  
  // 直接覆盖结果
  applyAutoResult(result, state)
}
```

**修改后**：
```javascript
const continueChallenge = async () => {
  const res = await http.post('/tower/auto', {
    tower_type: towerType.value,
    use_buff: buffEnabled.value,
    is_continue: true,  // 关键：继续挑战不消耗次数
  })
  
  if (res.data.ok) {
    const result = res.data.result
    const state = res.data.state
    
    // 合并新的战斗结果到现有结果
    // 累加奖励
    rewards.value.gold += result.total_rewards.gold || 0
    rewards.value.exp += result.total_rewards.exp || 0
    rewards.value.items.push(...(result.total_rewards.items || []))
    
    // 添加新的战斗记录（不覆盖旧记录）
    const newActivities = (result.battles || []).map((battle, index) => {
      // ... 生成新的活动记录
    })
    
    // 添加到战斗列表
    allBattles.value.push(...(result.battles || []))
    activities.value = [...newActivities.reverse(), ...activities.value]
    
    // 更新当前状态
    endFloor.value = result.end_floor
    stoppedReason.value = result.stopped_reason
    
    // ... 更新其他状态
  }
}
```

**说明**：
- 传递 `is_continue: true` 参数，表示继续挑战
- 累加奖励，而不是覆盖
- 合并战斗记录，保留之前的战斗历史
- 更新缓存，保存完整的闯塔结果

### 3. 修复次数消耗逻辑

#### application/services/tower_service.py

**修改函数签名**：
```python
def auto_challenge(
    self,
    user_id: int,
    tower_type: str,
    player_beasts: List[PlayerBeast],
    use_buff: bool = True,
    is_continue: bool = False,  # 新增参数
) -> AutoChallengeResult:
```

**修改次数消耗逻辑**：
```python
# 只有首次进入自动闯塔时才增加次数，继续挑战不增加
if not is_continue:
    state.today_count += 1
```

**说明**：
- 添加 `is_continue` 参数
- 只有 `is_continue=False` 时才消耗次数
- 继续挑战时 `is_continue=True`，不消耗次数

#### interfaces/routes/tower_routes.py

**修改路由**：
```python
@tower_bp.post("/tower/auto")
def tower_auto_challenge():
    data = request.get_json() or {}
    tower_type = data.get("tower_type", "tongtian")
    use_buff = data.get("use_buff", True)
    is_continue = data.get("is_continue", False)  # 获取参数
    
    result = services.tower_service.auto_challenge(
        user_id=user_id,
        tower_type=tower_type,
        player_beasts=player_beasts,
        use_buff=use_buff,
        is_continue=is_continue,  # 传递参数
    )
```

**说明**：
- 从请求中获取 `is_continue` 参数
- 传递给 `tower_service.auto_challenge`

## 修改效果

### 修改前的流程

1. 用户点击"自动闯塔" → 消耗1次，开始闯塔
2. 在40层失败 → `autoEnabled = false`，显示"自动闯塔：已关闭"
3. 用户点击"继续挑战" → 消耗1次，重新闯塔
4. 之前的战斗记录被覆盖 → 用户看不到之前的战斗历史

**问题**：
- 状态不明确（已关闭 vs 还在闯塔中）
- 继续挑战消耗额外次数
- 战斗记录丢失

### 修改后的流程

1. 用户点击"自动闯塔" → 消耗1次，开始闯塔
2. 在40层失败 → 保持"自动闯塔：已经开启"，显示"挑战失败"
3. 用户点击"继续挑战" → 不消耗次数，从40层继续
4. 新的战斗记录追加到列表 → 用户可以看到完整的战斗历史
5. 用户点击"退出此次闯塔" → 发放累积奖励，真正结束闯塔

**优势**：
- 状态清晰（一直保持"已经开启"，直到点击退出）
- 继续挑战不消耗额外次数
- 完整保留战斗历史
- 累积奖励正确计算

## 技术细节

### 闯塔次数管理

**次数消耗时机**：
- ✅ 首次点击"自动闯塔"进入页面
- ❌ 点击"继续挑战"
- ❌ 点击"刷新"（使用缓存，不调用接口）

**次数检查时机**：
- 每次调用 `auto_challenge` 都会检查次数
- 如果次数不足，抛出 `TowerError`

### 战斗记录管理

**数据结构**：
```javascript
{
  allBattles: [],      // 所有战斗详情
  activities: [],      // 战斗记录（用于显示）
  rewards: {           // 累积奖励
    gold: 0,
    exp: 0,
    items: []
  }
}
```

**合并策略**：
- 新的战斗追加到 `allBattles` 末尾
- 新的活动记录插入到 `activities` 开头（最新的在前）
- 奖励累加（金币、经验、物品）

### 缓存管理

**缓存键**：
```javascript
const cacheKey = `autoTowerResult:${towerType.value}`
```

**缓存内容**：
```javascript
{
  result: {
    start_floor: 1,
    end_floor: 40,
    battles: [...],
    total_rewards: {...},
    stopped_reason: 'all_dead'
  },
  state: {
    current_floor: 40,
    max_floor_record: 40,
    today_count: 1
  }
}
```

**缓存更新时机**：
- 首次进入自动闯塔页面
- 点击"继续挑战"后
- 点击"退出此次闯塔"时清除

## 测试建议

### 测试场景1：正常闯塔流程
1. 点击"自动闯塔"进入页面
2. 检查今日次数是否减少1次
3. 闯塔到某一层失败
4. 检查是否显示"自动闯塔：已经开启"
5. 检查是否显示"挑战失败"

### 测试场景2：继续挑战
1. 在失败后点击"继续挑战"
2. 检查今日次数是否保持不变（不再减少）
3. 检查是否从失败的层继续挑战
4. 检查战斗记录是否累加（不覆盖）
5. 检查奖励是否累加

### 测试场景3：退出闯塔
1. 点击"退出此次闯塔"
2. 检查是否返回闯塔主页
3. 检查累积奖励是否发放到背包
4. 检查缓存是否清除

### 测试场景4：次数用尽
1. 使用完所有闯塔次数
2. 尝试再次进入自动闯塔
3. 检查是否提示"今日闯塔次数已用完"

### 测试场景5：刷新页面
1. 在闯塔过程中刷新浏览器
2. 检查是否从缓存恢复状态
3. 检查战斗记录是否完整
4. 检查奖励是否正确

## 相关文件

### 修改的文件
1. `application/services/tower_service.py` - 添加 `is_continue` 参数，修复次数消耗逻辑
2. `interfaces/routes/tower_routes.py` - 传递 `is_continue` 参数
3. `interfaces/client/src/features/tower/TowerChallengePage.vue` - 修复继续挑战逻辑，修复状态显示

### 相关文件（未修改）
1. `domain/entities/tower.py` - 塔实体定义
2. `infrastructure/config/tower_config.py` - 塔配置

## 注意事项

### 1. 闯塔次数
- 每日次数在首次进入自动闯塔时消耗
- 继续挑战不消耗额外次数
- 退出闯塔后，如果还有次数，可以再次进入

### 2. 战斗记录
- 战斗记录会累积，不会覆盖
- 退出闯塔后，战斗记录会清除
- 刷新页面会从缓存恢复战斗记录

### 3. 奖励发放
- 奖励在闯塔过程中累积
- 点击"退出此次闯塔"时发放到背包
- 如果不点击退出，奖励不会发放

### 4. 缓存管理
- 缓存用于页面刷新后恢复状态
- 退出闯塔时会清除缓存
- 不同塔类型使用不同的缓存键

## 后续优化建议

### 1. 添加确认对话框
- 点击"退出此次闯塔"时，弹出确认对话框
- 显示累积奖励，让用户确认是否退出

### 2. 优化战斗记录显示
- 添加分页功能，避免记录过多时页面过长
- 添加筛选功能，只显示胜利或失败的记录

### 3. 添加战斗统计
- 显示总挑战次数、胜利次数、失败次数
- 显示最高到达层数
- 显示平均每层用时

### 4. 优化继续挑战提示
- 在继续挑战前，显示当前层的守塔幻兽信息
- 提示用户是否需要调整战斗队
- 显示预计胜率

---

**修复完成时间**：2026年1月18日  
**修复人员**：Kiro AI Assistant  
**版本**：v1.0
